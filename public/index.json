[{"content":"HTTP/2 es una versión más moderna y eficiente de HTTP que tiene algunas diferencias importantes con respecto a HTTP/1. En HTTP/2, todos los headers son transmitidos en formato binario y se espera que sean en minúscula. Esto significa que si envía un encabezado con mayúsculas, es posible que no sean reconocidos por el servidor y, por lo tanto, no se procesen correctamente.\nPor ejemplo, si mandamos un header como POWERED_BY sin avisar y sin mostrar ningun tipo de log o warning el cliente de HTTP/2 va a modificar y enviar el header como powered_by Causando que el servicio que esta esperando el header todo en mayusculas, lo reciba todo en minusculas, eso haria que no encuentre el header y por lo tanto entienda que el header no fue enviado, ejecundo un flujo totalmente distinto.\nEn algunos casos, no tenemos acceso al API en cuestion para modificar el header esperado, por lo que la solución es usar HTTP/1 en lugar de HTTP/2. HTTP/1 no tiene restricciones en cuanto a la forma en que los headers deben ser transmitidos, por lo que podemos enviar headers con mayúsculas, camelCase, etc sin problemas.\nSi estás desarrollando en Go y queres forzar al cliente a hacer un request con HTTP/1, podes hacerlo usando la lib estándar \u0026ldquo;net/http\u0026rdquo;. Para eso, tenes que crear un cliente HTTP con la opción \u0026ldquo;Transport\u0026rdquo; especificando la versión HTTP que deseas usar. Ejemplo en código:\npackage main import ( \u0026#34;crypto/tls\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { // Creamos un cliente HTTP con la opción \u0026#34;Transport\u0026#34; especificando que se desea usar HTTP/1 client := \u0026amp;http.Client{ Transport: \u0026amp;http.Transport{ // Deshabilitamos el protocolo TLSNextProto TLSNextProto: make(map[string]func(authority string, c *tls.Conn) http.RoundTripper), }, } // Realizamos la solicitud usando el cliente HTTP creado req, err := http.NewRequest(\u0026#34;GET\u0026#34;, \u0026#34;https://example.com/\u0026#34;, nil) // Es importante que los headers los setiemos de esta manera ya que si usamos Add() o Set() // Pasa por un proceso de canonicalizado que termina modificando el header tambien por mas que // Usemos HTTP/1 req.Header = map[string][]string{ \u0026#34;POWERED_BY\u0026#34;: {\u0026#34;GO\u0026#34;}, } if err != nil { fmt.Println(err) } resp, err := client.Do(req) if err != nil { fmt.Println(err) } defer resp.Body.Close() // Leemos el contenido de la respuesta body, err := ioutil.ReadAll(resp.Body) if err != nil { fmt.Println(err) } // Imprimimos el contenido de la respuesta fmt.Println(string(body)) } Ejemplo de request recibida por HTTP/2 Ejemplo de request recibida por HTTP/1 En resumen, si estás teniendo problemas con los headers en HTTP/2, podes solucionarlo usando HTTP/1 y forzando a tu cliente de Go a hacer la solicitud con esta versión de HTTP. Para eso, tenes que crear un cliente HTTP con la opción \u0026ldquo;Transport\u0026rdquo; deshabilitada\n","permalink":"https://blog.brianardiles.com/posts/my-3-post/","summary":"HTTP/2 es una versión más moderna y eficiente de HTTP que tiene algunas diferencias importantes con respecto a HTTP/1. En HTTP/2, todos los headers son transmitidos en formato binario y se espera que sean en minúscula. Esto significa que si envía un encabezado con mayúsculas, es posible que no sean reconocidos por el servidor y, por lo tanto, no se procesen correctamente.\nPor ejemplo, si mandamos un header como POWERED_BY sin avisar y sin mostrar ningun tipo de log o warning el cliente de HTTP/2 va a modificar y enviar el header como powered_by Causando que el servicio que esta esperando el header todo en mayusculas, lo reciba todo en minusculas, eso haria que no encuentre el header y por lo tanto entienda que el header no fue enviado, ejecundo un flujo totalmente distinto.","title":"Cómo forzar un request HTTP/1 en Go"},{"content":"Que es una permutacion Para saber si dos strings son permutaciones, primero tenemos que saber que es una permutacion, son aquellas palabras que contienen exactamente los mismos caracteres, pero esta ordenados de una manera distinta, por ejemplo, una permutacion de AUTO podría ser ATOU, otra podría ser OAUT, etc\nSabiendo esto podemos empezar a escribir el programa en Go que nos diga si dos strings son permutaciones o no. Hay varias formas de hacerlo, algunas mas optimas que otras\nComo puedo saber si son o no permutaciones Unas de las maneras podría ser: Tengo dos strings, por ejemplo \u0026ldquo;CASA\u0026rdquo; y \u0026ldquo;SAAC\u0026rdquo; sabiendo esto lo que podría hacer seria ordenar alfabéticamente los dos strings y comparar si son iguales, si lo son, quiere decir que una es la permutacion de la otra, si no son iguales, es que no lo son.\nOtra manera, mas optima, podría ser contando la cantidad de caracteres repetidos que tiene un string y restando los caracteres repetidos del otro, de esta manera, si la cantidad es igual a 0 quiere decir que los dos string tienen exactamente los mismos caracteres, por lo tanto son permutaciones.\nEsta ultima forma es mas optima porque nos ahorramos el paso de ordenar ese string, por lo tanto si es muy largo, estamos ahorrando bastante memoria y tiempo de procesamiento.\nEl codigo Una implementación de la ultima forma, podría ser algo así:\npackage main import ( \u0026#34;fmt\u0026#34; ) func main() { a := \u0026#34;casa\u0026#34; b := \u0026#34;csaa\u0026#34; fmt.Println(isPermutation(a,b)) } func isPermutation(a,b string) bool{ /* Si los string no son del mismo largo, no hay forma * de que sean permutaciones por lo tanto nos podemos * ahorrar el resto del proceso */ if len(a) != len(b){ return false } /* Seteamos un mapa que nos va permitir llevar * la cuenta, ej: {c:1, a:1 ...} */ characterCount := make(map[string]int) /* Recorre el string \u0026#34;A\u0026#34; caracter por caracter y suma * 1 por cara vez que aparece el mismo caracter */ for _, character := range a { characterCount[string(character)] += 1 } /* Esto hace lo contrario recorre el string \u0026#34;B\u0026#34; * y resta 1 por cada vez que aparece el mismo caracter */ for _, character := range b { characterCount[string(character)] -= 1 } /* Recorre el mapa que se armo anteriormente y si alguno * de los caracteres es distinto a 0 quiere decir que * los string no son permutaciones */ for _, characterAppears := range characterCount { if characterAppears != 0 { return false } } return true } El código se puede probar en el play ground de Go\n","permalink":"https://blog.brianardiles.com/posts/go-permutaciones/","summary":"Que es una permutacion Para saber si dos strings son permutaciones, primero tenemos que saber que es una permutacion, son aquellas palabras que contienen exactamente los mismos caracteres, pero esta ordenados de una manera distinta, por ejemplo, una permutacion de AUTO podría ser ATOU, otra podría ser OAUT, etc\nSabiendo esto podemos empezar a escribir el programa en Go que nos diga si dos strings son permutaciones o no. Hay varias formas de hacerlo, algunas mas optimas que otras","title":"Como saber si dos strings son permutaciones con Go"},{"content":"Que es una goroutine? Una goroutine es como un hilo, pero manejado por Go. Es mas liviano que un hilo tradicional y al estar completamente integrado al lenguaje, es mas sencillo de implementar.\nQue beneficios tienen? Las principales ventajas que tienen estas goroutines es que están muy bien optimizadas en la gestión de recursos, por lo tanto es posible tener cientos o hasta miles de goroutines a un costo mucho menor que si fueran hilos tradicionales.\nOtro de los beneficios es que al estar integradas al lenguaje su implementacion es mas sencilla y nos abstrae de lo que seria el manejo de esos \u0026ldquo;hilos\u0026rdquo;. Esto nos permite realizar varias operaciones en \u0026ldquo;simultaneo\u0026rdquo; (no es realmente simultaneo, porque son concurrentes y no paralelas) con menos codigo.\nComo ejecutar una goroutine La forma de iniciar una go routine es llamando una funcion y agregando la keyword go delante.\nEjemplo:\nSi tenemos la función getName() la manera de iniciarla como una gorutine seria: go getName()\npackage main import ( \u0026#34;fmt\u0026#34; ) func getName(){ fmt.Println(\u0026#34;Brian\u0026#34;) } func main() { fmt.Println(\u0026#34;Hola, mi nombre es: \u0026#34;) go getName() } Probar codigo\n####Que paso Si probaron el código se dieron cuenta de que, lo único que se imprimió fue Hola, mi nombre es: y no se imprimió Brian que fue el print que se ejecuto en la goroutine. Esto se debe a que la función main() también es una goroutine y cuando una goroutine termina, todas las sub-goroutines que se estén ejecutando mueren al morir la principal.\nPor lo tanto, main() se ejecuto, esta llamo a la función getName() como una goroutine, pero al finalizar main() antes que getName(), el print de \u0026ldquo;Brian\u0026rdquo; nunca se ejecuto.\nUna manera de comprobar esto que dije, seria agregando un sleep en la funcion main() abajo del go getName() para que se quede esperando ese sleep de por ejemplo 10 segundos, y efectivamente ver que la funcion getName() se esta ejecutando. Obviamente esta \u0026ldquo;solucion\u0026rdquo; es solo para probar, no serviria en un entorno productivo porque no podemos saber de antemano cuanto llevaria la ejecucion, por lo tanto una mejor manera seria que la goroutine nos avise cuando termino de ejecutarse, para ahi si, pasar a cerrar la goroutine principal.\nEntran a jugar los channels Para que esto funcione, hay que sincronizar las rutinas y para lograrlo se tienen que usar los channels (existen otras maneras, pero en este caso vamos a ver channels). Los channels vendrian a ser como las tuberías que conectan las goroutines y permiten transmitir datos de un lado al otro\nPara crear un channel hay que usar la función make() de la siguiente manera: make(chan type) donde chan vendria a ser la palabra reservada para los channels y type vendria a ser el tipo de dato que va a traficar ese channel\nEn este caso, lo que vamos a hacer es crear un channel de tipo bool el cual se va a quedar esperando a que la goroutine secundaria termine y al terminar la goroutine va a enviar un true a traves de ese channel indicando que termino. Porque algo que no explique, es que una función que esta escuchando un channel, no finaliza hasta que el channel es leído.\nEsto sucede porque el operador que se utiliza para leer un channel \u0026lt;- es un operador bloqueante, por lo tanto mientras en el channel no se escriba y se lea algo, el programa no termina nunca (en realidad el compilador no dejaría que esto pase, y nos avisaría antes de qué hay un error de lógica al momento de compilar, pero en el caso de que no se de cuenta del deadlock esto podría llegar a pasar) por lo tanto hay que tener cuidado con este operador.\nLa forma en que funciona este operador \u0026lt;- es la siguiente:\nSi la variable esta del lado derecho, esta \u0026ldquo;sacando\u0026rdquo; datos, por lo tanto esta leyendo, si la variable esta del lado izquierdo, esta \u0026ldquo;metiendo\u0026rdquo; datos a ese channel, es el mismo operador para los dos casos, no cambia dependiendo de si escribe o lee, lo que cambia es la posicion de las variables / datos\nejemplo:\n\u0026lt;- done // esta leyendo los datos de done done \u0026lt;- true // esta escribiendo true dentro del channel done package main import ( \u0026#34;fmt\u0026#34; ) func main() { done := make(chan bool) // creo un channel del tipo bool fmt.Println(\u0026#34;Hola, mi nombre es: \u0026#34;) go getName(done) // le pasamos el channel para que lo pueda escribir \u0026lt;- done // me quedo escuchando el channel y bloqueando hasta que llegue un mensaje } // recibimos el channel como variable para poder escribirlo func getName(done chan bool){ fmt.Println(\u0026#34;Brian\u0026#34;) // hago el print de Brian done \u0026lt;- true // escribo en el channel true para indicar que la rutina termino } Probar codigo\nCon eso ya tenemos las rutinas sincronizadas y funcionando sin problemas usando channels :)\n","permalink":"https://blog.brianardiles.com/posts/go-channels/","summary":"Que es una goroutine? Una goroutine es como un hilo, pero manejado por Go. Es mas liviano que un hilo tradicional y al estar completamente integrado al lenguaje, es mas sencillo de implementar.\nQue beneficios tienen? Las principales ventajas que tienen estas goroutines es que están muy bien optimizadas en la gestión de recursos, por lo tanto es posible tener cientos o hasta miles de goroutines a un costo mucho menor que si fueran hilos tradicionales.","title":"Goroutines y channels en Go"}]